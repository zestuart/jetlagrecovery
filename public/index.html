<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jet Lag Recovery Tracker</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #eff6ff 0%, #e0e7ff 100%);
        }
    </style>
</head>
<body class="gradient-bg min-h-screen">
    <div id="loading" class="flex items-center justify-center min-h-screen">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p class="text-gray-600">Loading Jet Lag Tracker...</p>
        </div>
    </div>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;

        const JetLagTracker = () => {
            const [ouraToken, setOuraToken] = useState('');
            const [travelData, setTravelData] = useState({
                departure: '',
                destination: '',
                timezoneShift: 0,
                direction: 'east'
            });
            const [recoveryData, setRecoveryData] = useState([]);
            const [currentRecovery, setCurrentRecovery] = useState(0);
            const [recommendations, setRecommendations] = useState([]);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [debugInfo, setDebugInfo] = useState('');

            const baseline = {
                avgRestingHr: 52,
                avgSleepEfficiency: 88
            };

            // Use local API endpoints with enhanced error handling
            const fetchOuraData = async (date) => {
                // Ensure date is properly formatted
                const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD format
                
                // Add date validation
                if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    throw new Error(`Invalid date format: ${dateStr}. Expected YYYY-MM-DD`);
                }
                
                console.log(`Fetching data for date: ${dateStr} (ISO: ${date.toISOString()})`);
                
                try {
                    // Ensure token doesn't already have "Bearer " prefix
                    const authToken = ouraToken.startsWith('Bearer ') ? ouraToken : `Bearer ${ouraToken}`;
                    
                    const response = await fetch(`/api/oura/combined/${dateStr}`, {
                        headers: {
                            'Authorization': authToken,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // Log detailed data quality
                    console.log(`Data quality for ${dateStr}:`, {
                        hasSleep: data.dataQuality.hasSleep,
                        sleepEfficiency: data.sleep?.efficiency || 'No sleep data',
                        sleepDay: data.sleep?.day || 'N/A',
                        bedtimeStart: data.sleep?.bedtime_start || 'N/A',
                        hrBPM: data.heartrate?.bpm?.toFixed(1) || 'No HR data',
                        tempDev: data.readiness?.temperature_trend_deviation || 'No readiness data'
                    });
                    
                    setDebugInfo(prev => 
                        prev + `\n${dateStr}: Sleep=${data.dataQuality.hasSleep}, ` +
                        `Efficiency=${data.sleep?.efficiency || 'N/A'}, ` +
                        `HR=${data.dataQuality.hasHeartRate}, ` +
                        `Readiness=${data.dataQuality.hasReadiness}`
                    );
                    
                    return data;
                } catch (error) {
                    setDebugInfo(prev => prev + `\n${dateStr}: Error - ${error.message}`);
                    throw error;
                }
            };

            const calculateRecoveryScore = (ouraData, daysSinceTravel) => {
                if (daysSinceTravel === 0) return 100;
                if (!ouraData.hasData) return null;
                
                let totalWeight = 0;
                let weightedScore = 0;
                
                // Body clock alignment (40% weight) - only if sleep data exists
                if (ouraData.sleep && ouraData.sleep.bedtime_start && ouraData.sleep.bedtime_end) {
                    const sleepMidpoint = calculateSleepMidpoint(ouraData.sleep);
                    const targetMidpoint = adjustedOptimalMidpoint(travelData.timezoneShift);
                    const alignment = Math.max(0, 100 - Math.abs(getTimeDifference(sleepMidpoint, targetMidpoint)) * 10);
                    
                    weightedScore += alignment * 0.4;
                    totalWeight += 0.4;
                } else {
                    console.warn(`No sleep data for recovery calculation - day ${daysSinceTravel}`);
                }
                
                // Heart rate recovery (25% weight)
                if (ouraData.heartrate.bpm && baseline.avgRestingHr) {
                    const hrDeviation = Math.abs(ouraData.heartrate.bpm - baseline.avgRestingHr);
                    const hrRecovery = Math.max(0, 100 - (hrDeviation / baseline.avgRestingHr) * 100);
                    
                    weightedScore += hrRecovery * 0.25;
                    totalWeight += 0.25;
                }
                
                // Temperature rhythm (20% weight)
                if (ouraData.readiness && ouraData.readiness.temperature_trend_deviation !== null) {
                    const tempAlignment = Math.max(0, 100 - Math.abs(ouraData.readiness.temperature_trend_deviation) * 250);
                    
                    weightedScore += tempAlignment * 0.2;
                    totalWeight += 0.2;
                }
                
                // Sleep efficiency (15% weight) - only if sleep data exists
                if (ouraData.sleep && ouraData.sleep.efficiency && baseline.avgSleepEfficiency) {
                    const sleepQuality = Math.min(100, (ouraData.sleep.efficiency / baseline.avgSleepEfficiency) * 100);
                    
                    weightedScore += sleepQuality * 0.15;
                    totalWeight += 0.15;
                }
                
                // Adjust weights if sleep data is missing
                if (!ouraData.sleep) {
                    console.log(`Calculating recovery without sleep data for day ${daysSinceTravel} - using ${totalWeight} total weight`);
                }
                
                // Return null if we have less than 30% of the data needed
                return totalWeight > 0.3 ? (weightedScore / totalWeight) : null;
            };

            const calculateSleepMidpoint = (sleepData) => {
                const start = new Date(sleepData.bedtime_start);
                const end = new Date(sleepData.bedtime_end);
                const midpoint = new Date((start.getTime() + end.getTime()) / 2);
                return midpoint.toTimeString().slice(0, 5);
            };

            const adjustedOptimalMidpoint = (timezoneShift) => {
                const baseHour = 3;
                const adjustedHour = (baseHour + timezoneShift + 24) % 24;
                return `${adjustedHour.toString().padStart(2, '0')}:00`;
            };

            const getTimeDifference = (time1, time2) => {
                const [h1, m1] = time1.split(':').map(Number);
                const [h2, m2] = time2.split(':').map(Number);
                const minutes1 = h1 * 60 + m1;
                const minutes2 = h2 * 60 + m2;
                const diff = Math.abs(minutes1 - minutes2);
                return Math.min(diff, 1440 - diff) / 60;
            };

            const generateRecommendations = (recoveryScore, daysSinceTravel) => {
                const recs = [];
                
                if (recoveryScore >= 95 || daysSinceTravel > 21) {
                    recs.push({
                        text: 'Full recovery achieved! Your circadian rhythm should be completely adapted.',
                        priority: 'low'
                    });
                    return recs;
                }
                
                if (recoveryScore < 70) {
                    if (travelData.direction === 'east') {
                        recs.push({
                            text: `Seek bright light exposure in early morning to advance your circadian rhythm`,
                            priority: 'high'
                        });
                    } else {
                        recs.push({
                            text: `Avoid bright light in the evening after 19:00 to delay your circadian rhythm`,
                            priority: 'high'
                        });
                    }
                }

                if (recoveryScore < 60) {
                    recs.push({
                        text: `Consider 1-2mg melatonin 30 minutes before target bedtime`,
                        priority: 'medium'
                    });
                }

                if (daysSinceTravel <= 3) {
                    recs.push({
                        text: 'Keep exercise light and preferably in the morning to support circadian adjustment',
                        priority: 'medium'
                    });
                }

                return recs;
            };

            const checkDataAvailability = async () => {
                if (!ouraToken || !travelData.departure) {
                    alert('Please enter token and travel date first');
                    return;
                }
                
                const startDate = new Date(travelData.departure);
                const endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + 7);
                
                setLoading(true);
                try {
                    // Ensure token doesn't already have "Bearer " prefix
                    const authToken = ouraToken.startsWith('Bearer ') ? ouraToken : `Bearer ${ouraToken}`;
                    
                    const response = await fetch(
                        `/api/oura/sleep-range/${startDate.toISOString().split('T')[0]}/${endDate.toISOString().split('T')[0]}`,
                        {
                            headers: {
                                'Authorization': authToken,
                                'Content-Type': 'application/json'
                            }
                        }
                    );
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        setError(`API Error: ${data.error}`);
                    } else if (data.data) {
                        const sleepDates = data.data.map(s => s.day).join(', ');
                        alert(`Found ${data.data.length} sleep records:\n${sleepDates || 'None'}\n\nIf dates are missing, ensure your ring was worn and synced.`);
                    }
                } catch (error) {
                    setError(`Check failed: ${error.message}`);
                } finally {
                    setLoading(false);
                }
            };

            const testAPI = async () => {
                if (!ouraToken.trim()) {
                    setError('Please enter your Ōura API token first');
                    return;
                }

                setLoading(true);
                setError('');
                setDebugInfo('Testing local API connection to Ōura...');

                try {
                    // Ensure token doesn't already have "Bearer " prefix
                    const authToken = ouraToken.startsWith('Bearer ') ? ouraToken : `Bearer ${ouraToken}`;
                    
                    const response = await fetch('/api/oura/test', {
                        headers: {
                            'Authorization': authToken,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    setDebugInfo(prev => prev + `\nAPI Test Successful! User: ${result.userInfo.email}`);
                    setError(''); // Clear any previous errors
                    alert(`✅ Local API working! Token validated successfully.\n\nSleep records found: ${result.sleepRecordCount || 0}\nRecent dates: ${result.recentSleepDates?.join(', ') || 'None'}`);
                    
                } catch (error) {
                    setError(`API Test Failed: ${error.message}`);
                    setDebugInfo(prev => prev + `\nAPI Test Failed: ${error.message}`);
                } finally {
                    setLoading(false);
                }
            };

            const startTracking = async () => {
                if (!ouraToken.trim()) {
                    setError('Please enter your Ōura API token first');
                    return;
                }

                setLoading(true);
                setError('');
                setDebugInfo('Starting recovery analysis...');
                
                try {
                    // First, check what sleep data is available
                    setDebugInfo(prev => prev + '\nChecking available sleep data range...');
                    
                    const today = new Date();
                    const thirtyDaysAgo = new Date(today);
                    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                    
                    const authToken = ouraToken.startsWith('Bearer ') ? ouraToken : `Bearer ${ouraToken}`;
                    
                    // Check what sleep data is available
                    const sleepRangeResponse = await fetch(
                        `/api/oura/sleep-range/${thirtyDaysAgo.toISOString().split('T')[0]}/${today.toISOString().split('T')[0]}`,
                        {
                            headers: {
                                'Authorization': authToken,
                                'Content-Type': 'application/json'
                            }
                        }
                    );
                    
                    const sleepRangeData = await sleepRangeResponse.json();
                    const availableSleepDates = sleepRangeData.data?.map(s => s.day) || [];
                    
                    if (availableSleepDates.length === 0) {
                        throw new Error('No sleep data found in your Oura account. Please sync your ring and try again.');
                    }
                    
                    const earliestSleepDate = new Date(availableSleepDates[0]);
                    const latestSleepDate = new Date(availableSleepDates[availableSleepDates.length - 1]);
                    
                    setDebugInfo(prev => prev + `\nSleep data available from ${earliestSleepDate.toLocaleDateString()} to ${latestSleepDate.toLocaleDateString()}`);
                    
                    const data = [];
                    const travelDate = new Date(travelData.departure);
                    
                    // Validate travel date against available data
                    if (travelDate < earliestSleepDate) {
                        setDebugInfo(prev => prev + `\n⚠️ Travel date (${travelDate.toLocaleDateString()}) is before earliest sleep data (${earliestSleepDate.toLocaleDateString()})`);
                        setDebugInfo(prev => prev + `\nAdjusting analysis to start from ${earliestSleepDate.toLocaleDateString()}`);
                    }
                    
                    const analysisStartDate = travelDate < earliestSleepDate ? earliestSleepDate : travelDate;
                    const daysSinceTravel = Math.floor((today - analysisStartDate) / (1000 * 60 * 60 * 24));
                    
                    setDebugInfo(prev => prev + `\nAnalyzing ${daysSinceTravel} days since ${analysisStartDate.toLocaleDateString()}`);
                    
                    // Baseline (using the day before travel or first available data)
                    const baselineDate = new Date(analysisStartDate);
                    baselineDate.setDate(baselineDate.getDate() - 1);
                    
                    data.push({
                        day: 0,
                        date: analysisStartDate.toLocaleDateString('en-GB'),
                        recovery: 100,
                        sleepEfficiency: baseline.avgSleepEfficiency,
                        restingHr: baseline.avgRestingHr,
                        tempDeviation: 0,
                        isBaseline: true
                    });
                    
                    const daysToFetch = Math.min(daysSinceTravel, 14);
                    let successfulDataPoints = 0;
                    let missingSleepDays = [];
                    let skippedDays = [];
                    
                    for (let day = 1; day <= daysToFetch; day++) {
                        const currentDate = new Date(analysisStartDate);
                        currentDate.setDate(currentDate.getDate() + day);
                        const currentDateStr = currentDate.toISOString().split('T')[0];
                        
                        // Check if this date has sleep data
                        if (!availableSleepDates.includes(currentDateStr)) {
                            skippedDays.push(currentDateStr);
                            setDebugInfo(prev => prev + `\nDay ${day} (${currentDateStr}): No sleep data available - skipping`);
                            continue;
                        }
                        
                        try {
                            const ouraData = await fetchOuraData(currentDate);
                            
                            if (ouraData.hasData) {
                                const recoveryScore = calculateRecoveryScore(ouraData, day);
                                
                                if (recoveryScore !== null) {
                                    data.push({
                                        day,
                                        date: currentDate.toLocaleDateString('en-GB'),
                                        recovery: recoveryScore,
                                        sleepEfficiency: ouraData.sleep?.efficiency || null,
                                        restingHr: ouraData.heartrate?.bpm || null,
                                        tempDeviation: ouraData.readiness?.temperature_trend_deviation || null,
                                        isBaseline: false,
                                        dataQuality: ouraData.dataQuality
                                    });
                                    successfulDataPoints++;
                                    setDebugInfo(prev => prev + `\nDay ${day}: Recovery ${Math.round(recoveryScore)}%` + 
                                                               (ouraData.sleep ? ` (Sleep Eff: ${ouraData.sleep.efficiency}%)` : ' (No sleep data)'));
                                    
                                    // Track missing sleep data even for available dates
                                    if (!ouraData.dataQuality.hasSleep) {
                                        missingSleepDays.push(currentDate.toLocaleDateString('en-GB'));
                                    }
                                }
                            }
                        } catch (apiError) {
                            setDebugInfo(prev => prev + `\nDay ${day}: ${apiError.message}`);
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                    
                    if (successfulDataPoints === 0) {
                        throw new Error(`No Ōura data could be processed. Check the debug information above.`);
                    }
                    
                    // Report on data quality
                    if (skippedDays.length > 0) {
                        setDebugInfo(prev => prev + `\n\n📊 Skipped ${skippedDays.length} days with no Oura data`);
                    }
                    
                    if (missingSleepDays.length > 0) {
                        setDebugInfo(prev => prev + `\n⚠️ Days with missing sleep component: ${missingSleepDays.join(', ')}`);
                    }
                    
                    setRecoveryData(data);
                    const validPoints = data.filter(d => !d.isBaseline && d.recovery !== null);
                    const latestRecovery = validPoints.length > 0 ? validPoints[validPoints.length - 1].recovery : 0;
                    setCurrentRecovery(latestRecovery);
                    setRecommendations(generateRecommendations(latestRecovery, daysSinceTravel));
                    
                    setDebugInfo(prev => prev + `\n✅ Complete! ${successfulDataPoints} days analyzed successfully.`);
                    
                    // Add warning if travel date was before available data
                    if (travelDate < earliestSleepDate) {
                        setError(`Note: Your travel date (${travelDate.toLocaleDateString()}) was before your earliest Oura data (${earliestSleepDate.toLocaleDateString()}). Analysis started from first available data.`);
                    }
                    
                } catch (error) {
                    setError(error.message);
                    setDebugInfo(prev => prev + `\nError: ${error.message}`);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="min-h-screen gradient-bg p-6">
                    <div className="max-w-6xl mx-auto">
                        {/* Header */}
                        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                            <div className="flex items-center gap-3 mb-4">
                                <div className="w-8 h-8 bg-indigo-600 rounded flex items-center justify-center">
                                    <span className="text-white font-bold">✈</span>
                                </div>
                                <h1 className="text-3xl font-bold text-gray-900">Jet Lag Recovery Tracker</h1>
                            </div>
                            <p className="text-gray-600">Local Node.js application with real Ōura API integration - No CORS issues!</p>
                        </div>

                        {/* Token Input */}
                        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                            <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                                <div className="w-5 h-5 bg-red-500 rounded flex items-center justify-center">
                                    <span className="text-white text-xs">♥</span>
                                </div>
                                Ōura API Token
                            </h2>
                            <input
                                type="password"
                                value={ouraToken}
                                onChange={(e) => setOuraToken(e.target.value)}
                                placeholder="Enter your Ōura API token"
                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 mb-4"
                            />
                            <p className="text-xs text-gray-500 mb-4">
                                Get your token from <a 
                                    href="https://cloud.ouraring.com/personal-access-tokens" 
                                    className="text-indigo-600 hover:underline"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                >Ōura Cloud</a>
                            </p>
                            {ouraToken && (
                                <div className="flex gap-2">
                                    <button
                                        onClick={testAPI}
                                        disabled={loading}
                                        className="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        {loading ? 'Testing...' : 'Test API Connection'}
                                    </button>
                                    <button
                                        onClick={async () => {
                                            setLoading(true);
                                            try {
                                                // Ensure token doesn't already have "Bearer " prefix
                                                const authToken = ouraToken.startsWith('Bearer ') ? ouraToken : `Bearer ${ouraToken}`;
                                                
                                                // Test 1: Direct curl equivalent
                                                console.log('\n=== Running Sleep Direct Test (curl equivalent) ===');
                                                const directResponse = await fetch('/api/oura/sleep-direct-test', {
                                                    headers: {
                                                        'Authorization': authToken,
                                                        'Accept': 'application/json'
                                                    }
                                                });
                                                const directData = await directResponse.json();
                                                console.log('Direct test results:', directData);
                                                
                                                // Test 2: Different endpoints
                                                console.log('\n=== Testing Different Sleep Endpoints ===');
                                                const endpointsResponse = await fetch('/api/oura/sleep-endpoints-test', {
                                                    headers: {
                                                        'Authorization': authToken,
                                                        'Accept': 'application/json'
                                                    }
                                                });
                                                const endpointsData = await endpointsResponse.json();
                                                console.log('Endpoints test results:', endpointsData);
                                                
                                                // Show results
                                                alert(`Sleep API Diagnostic Results:\n\n` +
                                                      `Direct Test (curl equivalent):\n` +
                                                      `- Records found: ${directData.recordCount || 0}\n` +
                                                      `- Dates: ${directData.dates?.slice(0, 5).join(', ') || 'None'}\n\n` +
                                                      `Endpoint Tests:\n` +
                                                      Object.entries(endpointsData).map(([name, result]) => 
                                                          `- ${name}: ${result.success ? `✓ ${result.recordCount} records` : `✗ ${result.error}`}`
                                                      ).join('\n') +
                                                      `\n\nCheck browser console for detailed logs.`);
                                                      
                                                // If we found sleep data, log a sample
                                                if (directData.sampleRecord) {
                                                    console.log('Sample sleep record:', directData.sampleRecord);
                                                }
                                            } catch (error) {
                                                setError(`Diagnostic failed: ${error.message}`);
                                                console.error('Diagnostic error:', error);
                                            } finally {
                                                setLoading(false);
                                            }
                                        }}
                                        disabled={loading}
                                        className="bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        Run Sleep Diagnostics
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* Debug Panel */}
                        {debugInfo && (
                            <div className="bg-gray-50 rounded-xl border p-4 mb-6">
                                <h3 className="text-sm font-medium text-gray-700 mb-2">Debug Information</h3>
                                <pre className="text-xs text-gray-600 whitespace-pre-wrap font-mono bg-white p-2 rounded border max-h-32 overflow-y-auto">
                                    {debugInfo}
                                </pre>
                                <button 
                                    onClick={() => setDebugInfo('')}
                                    className="mt-2 text-xs text-gray-500 hover:text-gray-700"
                                >
                                    Clear Debug Info
                                </button>
                            </div>
                        )}

                        {/* Travel Form */}
                        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                            <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                                <div className="w-5 h-5 bg-blue-500 rounded flex items-center justify-center">
                                    <span className="text-white text-xs">⏰</span>
                                </div>
                                Travel Details
                            </h2>
                            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Departure</label>
                                    <input
                                        type="datetime-local"
                                        value={travelData.departure}
                                        onChange={(e) => setTravelData({...travelData, departure: e.target.value})}
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Destination</label>
                                    <input
                                        type="text"
                                        value={travelData.destination}
                                        onChange={(e) => setTravelData({...travelData, destination: e.target.value})}
                                        placeholder="e.g., London, UK"
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Timezone Shift (hours)</label>
                                    <input
                                        type="number"
                                        value={travelData.timezoneShift}
                                        onChange={(e) => setTravelData({...travelData, timezoneShift: parseInt(e.target.value) || 0})}
                                        placeholder="e.g., +8 for London from SF"
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Direction</label>
                                    <select
                                        value={travelData.direction}
                                        onChange={(e) => setTravelData({...travelData, direction: e.target.value})}
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                    >
                                        <option value="east">Eastward</option>
                                        <option value="west">Westward</option>
                                    </select>
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button
                                    onClick={startTracking}
                                    disabled={!travelData.departure || !travelData.destination || !travelData.timezoneShift || loading}
                                    className="bg-indigo-600 text-white px-6 py-2 rounded-md hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                >
                                    {loading ? 'Analyzing...' : 'Start Recovery Analysis'}
                                </button>
                                {ouraToken && travelData.departure && (
                                    <button
                                        onClick={checkDataAvailability}
                                        disabled={loading}
                                        className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        Check Data Availability
                                    </button>
                                )}
                            </div>
                        </div>

                        {/* Loading State */}
                        {loading && (
                            <div className="bg-white rounded-xl shadow-lg p-6 mb-6 text-center">
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-2"></div>
                                <p>Fetching your Ōura data via local server...</p>
                                <p className="text-sm text-gray-500 mt-1">This may take a moment as we process multiple days of data</p>
                            </div>
                        )}

                        {/* Error State */}
                        {error && (
                            <div className="bg-red-50 border border-red-200 rounded-xl p-6 mb-6">
                                <h3 className="font-medium text-red-800 mb-2">Error</h3>
                                <p className="text-red-700 text-sm whitespace-pre-line">{error}</p>
                            </div>
                        )}

                        {/* Results */}
                        {recoveryData.length > 0 && (
                            <div className="space-y-6">
                                {/* Recovery Status */}
                                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                    <div className="bg-white rounded-xl shadow-lg p-6 text-center">
                                        <h3 className="text-lg font-semibold mb-4">Current Recovery</h3>
                                        <div className="relative w-32 h-32 mx-auto mb-4">
                                            <div className="absolute inset-0 flex items-center justify-center">
                                                <div className="text-center">
                                                    <div className="text-4xl font-bold text-indigo-600">{Math.round(currentRecovery)}%</div>
                                                    <div className="text-sm text-gray-600">Recovery</div>
                                                </div>
                                            </div>
                                            <svg className="w-32 h-32 transform -rotate-90">
                                                <circle
                                                    cx="64"
                                                    cy="64"
                                                    r="56"
                                                    stroke="#e5e7eb"
                                                    strokeWidth="8"
                                                    fill="none"
                                                />
                                                <circle
                                                    cx="64"
                                                    cy="64"
                                                    r="56"
                                                    stroke={currentRecovery > 80 ? '#22c55e' : currentRecovery > 60 ? '#f59e0b' : '#ef4444'}
                                                    strokeWidth="8"
                                                    fill="none"
                                                    strokeDasharray={`${(currentRecovery / 100) * 351.86} 351.86`}
                                                    className="transition-all duration-1000"
                                                />
                                            </svg>
                                        </div>
                                        <p className="text-sm text-gray-600">
                                            {recoveryData.filter(d => !d.isBaseline).length} days of real data
                                        </p>
                                        {currentRecovery >= 95 && (
                                            <div className="mt-2">
                                                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                                                    ✓ Fully Recovered
                                                </span>
                                            </div>
                                        )}
                                    </div>

                                    <div className="bg-white rounded-xl shadow-lg p-6">
                                        <h3 className="text-lg font-semibold mb-4">Latest Metrics</h3>
                                        <div className="space-y-3">
                                            <div className="flex justify-between items-center">
                                                <span className="text-sm">Resting HR</span>
                                                <span className="font-medium">
                                                    {recoveryData[recoveryData.length - 1]?.restingHr ? 
                                                        `${Math.round(recoveryData[recoveryData.length - 1].restingHr)} bpm` : 
                                                        'No data'}
                                                </span>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="text-sm">Sleep Efficiency</span>
                                                <span className="font-medium">
                                                    {recoveryData[recoveryData.length - 1]?.sleepEfficiency ? 
                                                        `${Math.round(recoveryData[recoveryData.length - 1].sleepEfficiency)}%` : 
                                                        'No data'}
                                                </span>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="text-sm">Temp Deviation</span>
                                                <span className="font-medium">
                                                    {recoveryData[recoveryData.length - 1]?.tempDeviation !== null && 
                                                     recoveryData[recoveryData.length - 1]?.tempDeviation !== undefined ? 
                                                        `${recoveryData[recoveryData.length - 1].tempDeviation >= 0 ? '+' : ''}${recoveryData[recoveryData.length - 1].tempDeviation.toFixed(2)}°C` : 
                                                        'No data'}
                                                </span>
                                            </div>
                                        </div>
                                    </div>

                                    <div className="bg-white rounded-xl shadow-lg p-6">
                                        <h3 className="text-lg font-semibold mb-4">Data Quality</h3>
                                        <div className="space-y-2 text-sm">
                                            <div>Total days analyzed: {recoveryData.filter(d => !d.isBaseline).length}</div>
                                            <div>Sleep records: {recoveryData.filter(d => d.dataQuality?.hasSleep).length}</div>
                                            <div>Heart rate data: {recoveryData.filter(d => d.dataQuality?.hasHeartRate).length}</div>
                                            <div>Readiness data: {recoveryData.filter(d => d.dataQuality?.hasReadiness).length}</div>
                                        </div>
                                    </div>
                                </div>

                                {/* Recommendations */}
                                {recommendations.length > 0 && (
                                    <div className="bg-white rounded-xl shadow-lg p-6">
                                        <h3 className="text-lg font-semibold mb-4">Personalized Recommendations</h3>
                                        <div className="space-y-4">
                                            {recommendations.map((rec, index) => (
                                                <div 
                                                    key={index}
                                                    className={`p-4 rounded-lg border-l-4 ${
                                                        rec.priority === 'high' ? 'border-red-500 bg-red-50' :
                                                        rec.priority === 'medium' ? 'border-yellow-500 bg-yellow-50' :
                                                        'border-green-500 bg-green-50'
                                                    }`}
                                                >
                                                    <p className="text-sm">{rec.text}</p>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {/* Raw Data Summary */}
                                <div className="bg-white rounded-xl shadow-lg p-6">
                                    <h3 className="text-lg font-semibold mb-4">Recovery Data Summary</h3>
                                    <div className="overflow-x-auto">
                                        <table className="min-w-full text-sm">
                                            <thead>
                                                <tr className="border-b">
                                                    <th className="text-left py-2">Day</th>
                                                    <th className="text-left py-2">Date</th>
                                                    <th className="text-left py-2">Recovery %</th>
                                                    <th className="text-left py-2">Sleep Eff %</th>
                                                    <th className="text-left py-2">Resting HR</th>
                                                    <th className="text-left py-2">Temp Dev</th>
                                                    <th className="text-left py-2">Data Sources</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {recoveryData.map((d, i) => (
                                                    <tr key={i} className="border-b">
                                                        <td className="py-2">{d.day}</td>
                                                        <td className="py-2">{d.date}</td>
                                                        <td className="py-2">{d.recovery ? Math.round(d.recovery) : '-'}</td>
                                                        <td className="py-2">{d.sleepEfficiency ? Math.round(d.sleepEfficiency) : '-'}</td>
                                                        <td className="py-2">{d.restingHr ? Math.round(d.restingHr) : '-'}</td>
                                                        <td className="py-2">{d.tempDeviation !== null ? Number(d.tempDeviation).toFixed(2) : '-'}</td>
                                                        <td className="py-2">
                                                            {d.isBaseline ? 'Baseline' : 
                                                             d.dataQuality ? [
                                                                 d.dataQuality.hasSleep ? 'Sleep' : null,
                                                                 d.dataQuality.hasHeartRate ? 'HR' : null,
                                                                 d.dataQuality.hasReadiness ? 'Readiness' : null
                                                             ].filter(Boolean).join(', ') : 'None'}
                                                        </td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Welcome Message */}
                        {!recoveryData.length && !loading && !error && (
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <h3 className="text-lg font-semibold mb-4">Ready for Real Data Analysis</h3>
                                <div className="space-y-4 text-sm">
                                    <div className="bg-green-50 p-4 rounded-lg border border-green-200">
                                        <h4 className="font-medium text-green-800 mb-2">✅ No CORS Issues</h4>
                                        <p className="text-green-700">
                                            This local Node.js setup bypasses all browser restrictions. Your Ōura API calls 
                                            are made server-side, ensuring reliable data access.
                                        </p>
                                    </div>
                                    
                                    <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
                                        <h4 className="font-medium text-blue-800 mb-2">📊 Real Data Only</h4>
                                        <p className="text-blue-700">
                                            Every metric comes directly from your Ōura ring. No estimates, no mock data - 
                                            just genuine physiological measurements for accurate jet lag assessment.
                                        </p>
                                    </div>
                                    
                                    <div className="bg-indigo-50 p-4 rounded-lg border border-indigo-200">
                                        <h4 className="font-medium text-indigo-800 mb-2">🔒 Privacy Protected</h4>
                                        <p className="text-indigo-700">
                                            Your Ōura data is processed locally on your machine. No external servers, 
                                            no data storage - complete privacy.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Hide loading message and render app
        document.getElementById('loading').style.display = 'none';
        ReactDOM.render(<JetLagTracker />, document.getElementById('root'));
    </script>
</body>
</html>